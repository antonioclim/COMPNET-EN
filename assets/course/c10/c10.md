### HTTP(S), REST si WebSockets
### Nivel aplicatie – comportament, performanta, corectitudine

---

### Context
Studentii au parcurs deja un curs de tehnologii web:
- React + Redux (SPA)
- Backend REST cu persistenta ORM
- Utilizare practica HTTP, REST, JSON

Acest curs:
- NU reia “cum construim un API”
- SE concentreaza pe ce se intampla efectiv in protocol
- Pune accent pe diagnosticare, interoperabilitate si performanta

---

### Obiective
La finalul cursului, studentul poate:
- Explica comportamentul real al HTTP pe o conexiune TCP
- Intelege impactul headerelor asupra comportamentului clientului
- Diferentia erori semantice HTTP apropiate (401 vs 403, 404 vs 405, etc.)
- Explica de ce unele cereri functioneaza in Postman dar nu in browser
- Intelege mecanismele de caching, negociere si compresie
- Intelege WebSocket ca extensie protocolara, nu “API JavaScript”
- Plasa REST, WebSocket si HTTPS corect in arhitectura Internet

---

### Unde se afla HTTP in arhitectura
- HTTP ruleaza peste TCP (sau QUIC)
- Se bazeaza pe:
  - conexiuni
  - latenta
  - retransmisii
- Majoritatea problemelor web sunt probleme de protocol, nu de framework

---

### HTTP: recap extrem de scurt
- Protocol de nivel aplicatie
- Model cerere–raspuns
- Initiere exclusiv de catre client
- Headere text + body arbitrar
- Fara stare implicita

---

### HTTP nu este “stateless” in practica
- Protocolul este stateless
- Aplicatiile nu sunt
- Starea este mutata:
  - in cookie-uri
  - in token-uri
  - in URL-uri
  - in server-side session stores
- Legatura directa cu conceptele de nivel sesiune (L5)

---

### Conexiunea HTTP
- HTTP/1.1 foloseste conexiuni persistente (Keep-Alive)
- Mai multe cereri pot fi trimise pe aceeasi conexiune TCP
- Ordinea raspunsurilor conteaza (head-of-line blocking)

---

### Costul real al unei cereri HTTP
- Nu bandwidth-ul este problema principala
- Ci:
  - latenta
  - handshake TCP
  - handshake TLS
  - round-trip-uri multiple
- Motivatie pentru HTTP/2 si HTTP/3

---

### Structura unei cereri HTTP (relevanta reala)
- Request line: metoda + path
- Headere:
  - controleaza comportamentul serverului
  - controleaza comportamentul browserului
- Body:
  - optional
  - interpretat exclusiv prin Content-Type

---

### Metode HTTP: semantica, nu conventie
- GET:
  - sigur
  - idempotent
  - cacheable
- PUT:
  - idempotent
  - inlocuire completa
- DELETE:
  - idempotent (efect final)
- POST:
  - nici sigur
  - nici idempotent

---

### De ce conteaza idempotenta
- Retrieri automate (proxy, client, load balancer)
- Timeout-uri
- Repetarea cererilor
- Legatura directa cu fiabilitatea (nivel transport)

---

### Coduri de status: semantica fina
- 401 Unauthorized:
  - lipsa autentificare
- 403 Forbidden:
  - autentificare ok, acces interzis
- 404 Not Found:
  - resursa inexistenta
- 405 Method Not Allowed:
  - resursa exista, metoda nu
- 415 Unsupported Media Type:
  - Content-Type incorect
- 422 Unprocessable Entity:
  - continut valid, semantica invalida

---

### Content-Type vs Accept
- Content-Type:
  - ce trimit
- Accept:
  - ce pot primi
- Negocierea este bidirectionala
- Multe bug-uri apar din nepotrivirea lor

---

### Compresie HTTP
- Clientul cere: Accept-Encoding
- Serverul raspunde: Content-Encoding
- gzip / br reduc traficul, dar:
  - cresc costul CPU
- Transparent pentru aplicatie, critic pentru performanta

---

### Cache HTTP: mecanism, nu magie
- Cache-Control, Expires
- Last-Modified / If-Modified-Since
- 304 Not Modified:
  - raspuns fara body
  - reduce drastic traficul
- Cache-ul este distribuit (browser, proxy, CDN)

---

### Cookie-uri: mecanism aplicatie
- Transmise prin headere HTTP
- Rezolva:
  - identificarea sesiunii
  - preferinte
- Flag-uri critice:
  - Secure
  - HttpOnly
  - SameSite
- Implicatii directe de securitate

---

### CORS: model de securitate al browserului
- Nu este o limitare a HTTP
- Este o politica de securitate a browserului
- Preflight:
  - cerere OPTIONS automata
  - declansata de metode sau headere “non-simple”
- Motivul clasic: “merge in Postman, nu in browser”

---

### HTTP/1.1: limitarile clasice
- Head-of-line blocking
- Headere repetate
- Multe cereri serializate

---

### HTTP/2: ce se schimba
- Multiplexare pe aceeasi conexiune
- Compresie headere
- Prioritizare stream-uri
- Fara schimbare semantica HTTP

---

### WebSocket: cand HTTP nu mai e suficient
- HTTP este initiat de client
- Serverul nu poate “impinge” date
- WebSocket rezolva:
  - bidirectionalitate
  - conexiuni lungi
  - notificari

---

### Handshake WebSocket
- Porneste ca cerere HTTP
- Upgrade de protocol
- Dupa handshake:
  - nu mai este HTTP
  - este protocol de tip frame peste TCP

---

### WebSocket vs HTTP polling
- Polling:
  - multe cereri goale
  - latenta
- WebSocket:
  - notificari reale
  - eficienta
- Trade-off: mentinerea conexiunii

---

### HTTPS: recap conceptual
- HTTP peste TLS
- Asigura:
  - confidentialitate
  - integritate
  - autentificare
- TLS se negociaza inainte de HTTP

---

### Ce schimba HTTPS operational
- Inspectia traficului devine imposibila fara MITM
- Certificatele definesc identitatea serverului
- Impact pe:
  - proxy-uri
  - caching
  - debugging

---

### REST: stil arhitectural, nu tehnologie
- Modeleaza domeniul ca resurse
- Foloseste semantica HTTP
- Este stateless
- Este orientat pe interoperabilitate

---

### Nivelurile REST (Richardson)
- Nivel 0: RPC peste HTTP
- Nivel 1: resurse adresabile
- Nivel 2: resurse + verbe + status
- Nivel 3: hypermedia (discoverability)

---

### REST corect vs REST “cosmetic”
- Actiuni in URL: semn de RPC
- POST folosit pentru orice: pierdere semantica
- Lipsa codurilor corecte: debugging dificil
- REST bun ajuta caching, proxy-uri, scalare

---

### REST vs SOAP (context)
- REST:
  - web-native
  - simplu
  - flexibil
- SOAP:
  - contract strict
  - XML
  - extensii enterprise (WS-*)
- Ambele rezolva probleme diferite

---

### Unde intra exemplele practice
- Inspectie trafic HTTP cu curl / browser devtools
- Demonstratii de:
  - caching
  - CORS
  - Content-Type gresit
  - WebSocket handshake
- Accent pe “de ce” si “ce se intampla”

---

### Recapitulare
- HTTP este un protocol, nu un framework
- Headerele controleaza comportamentul real
- REST inseamna folosirea corecta a HTTP
- WebSocket este extensie protocolara
- HTTPS schimba fundamental observabilitatea traficului
