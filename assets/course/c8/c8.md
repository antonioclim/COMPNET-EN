### Nivelul transport
### TCP, UDP, TLS, QUIC

---

### Obiective
La finalul cursului, studentul poate:
- Explica rolul nivelului transport in arhitectura de retea
- Explica mecanismul porturilor si multiplexarea proceselor
- Descrie functionarea protocolului TCP
- Explica rolul optiunilor TCP (MSS, SACK, window scaling)
- Compara TCP si UDP
- Intelege rolul TLS/DTLS
- Intelege motivatia aparitiei QUIC

---

### Rolul nivelului transport
- Identifica un proces specific care comunica in retea
- Face legatura intre nivelul retea si nivelul aplicatie
- Poate oferi fiabilitate si control al fluxului

---

### Ce probleme rezolva nivelul transport
- Identificarea proceselor (porturi)
- Multiplexarea comunicatiilor
- Controlul fluxului de date
- Fiabilitate (optional, in functie de protocol)

---

### Porturi
- Mecanismul fundamental la nivel transport
- Identifica un capat al comunicatiei
- Valori intre 0 si 65535 (16 biti)

---

### Porturi: client vs server
- Serverul foloseste un port fix
- Portul identifica serviciul
- Clientul isi alege un port liber (ephemeral)

---

### Clasificarea porturilor
- Porturi well-known: < 1024
- Porturi neprivilegiate: >= 1024
- Pot fi folosite liber

---

### Exemple de porturi well-known
- 80 – HTTP
- 25 – SMTP
- 21 – FTP
- 22 – SSH

---

### Protocoale de nivel transport
- TCP (Transmission Control Protocol)
- UDP (User Datagram Protocol)

---

### TCP vs UDP (idea)
- TCP: orientat pe conexiune
- UDP: fara conexiune
- Alegerea depinde de cerintele aplicatiei

---

### Protocolul TCP
- Orientat pe conexiune
- Relativ complex
- Ofera garantii de transmisie
- Overhead mai mare

---

### Structura generala TCP
- Transmite date ca stream
- Segmenteaza datele
- Numeroteaza fiecare segment

---

### Header-ul TCP (overview)
- Contine informatii de control
- Permite fiabilitate si controlul fluxului

[FIG] c8-assets/fig-tcp-header.png

---

### TCP: porturi
- Source port (16 biti)
- Destination port (16 biti)
- Identifica procesele implicate

---

### TCP: numerotarea segmentelor
- Sequence number (32 biti)
- Acknowledgement number (32 biti)
- Permit detectarea pierderilor si reordonarea

---

### TCP: campuri de control
- Data offset
- Camp rezervat
- Flag-uri

---

### Flag-uri TCP (1)
- SYN – initiere conexiune
- ACK – confirmare primire
- FIN – inchidere controlata

---

### Flag-uri TCP (2)
- RST – inchidere fortata
- PSH – livrare imediata
- URG – date urgente

---

### Flag-uri TCP (3)
- ECE, CWR – controlul congestiei
- Congestia apare cand reteaua este supraincarcata

---

### TCP: controlul fluxului
- Window (16 biti)
- Specifica cat poate primi receptorul
- Ajustabil dinamic

---

### TCP: integritatea datelor
- Checksum pe header si date
- Include pseudo-header IP

---

### Optiuni TCP – de ce exista?
- TCP este extensibil
- Optiunile permit adaptarea la retele moderne
- Negociate in handshake (SYN)

---

### Structura optiunilor TCP
- Kind (1 byte)
- Length (1 byte)
- Data (parametri specifici)

---

### MSS – Maximum Segment Size
- Dimensiunea maxima a datelor utile
- MSS + header = MTU
- Previne fragmentarea IP
- Transmis doar in SYN

---

### Selective Acknowledgement (SACK)
- TCP clasic confirma cumulativ
- SACK confirma intervale de date
- Reduce retransmisiile inutile
- Necesita negociere (SACK permitted)

[FIG] c8-assets/fig-tcp-sack.png

---

### Window scaling
- Campul window este limitat la 16 biti
- Scaling introduce un factor de multiplicare
- Esential pentru retele rapide

---

### TCP timestamps
- TSval si TSecr
- Estimare RTT
- Detectie segmente vechi (PAWS)

---

### TCP Fast Open
- Permite trimiterea de date in SYN
- Reduce latența de conectare
- Necesita suport bilateral

---

### NOP si End of Option List
- NOP: aliniere si delimitare
- End of list: sfarsitul optiunilor

---

### Mecanisme TCP (overview)
- Stabilirea conexiunii
- Terminarea conexiunii
- Fiabilitate
- Controlul fluxului

---

### Stabilirea conexiunii TCP
- Three-way handshake
- Schimbul numerelor initiale de secventa

[FIG] c8-assets/fig-tcp-handshake.png

---

### TCP Fast Open (context)
- Reduce handshake-ul clasic
- Datele pot fi trimise mai devreme

---

### Terminarea conexiunii TCP
- Inchidere controlata (4 segmente)
- Inchidere fortata (RST)

[FIG] c8-assets/fig-tcp-close.png

---

### Fiabilitate in TCP
- Fiecare segment este confirmat
- Retransmisii la pierdere
- Reordonare pe baza numerelor de secventa

---

### Controlul fluxului (detaliere)
- Window indica capacitatea receptorului
- Se poate modifica pe parcursul conexiunii

---

### Stari ale unui socket TCP
- Reflecta starea conexiunii
- Vizibile la nivel OS

---

### Stari TCP (1)
- CLOSED
- LISTEN
- ESTABLISHED
- FIN-WAIT-1

---

### Stari TCP (2)
- FIN-WAIT-2
- CLOSE-WAIT
- LAST-ACK
- CLOSING
- TIME-WAIT

---

### Protocoale bazate pe TCP
- HTTP (1.1, 2)
- FTP
- SMTP
- Alte protocoale de aplicatie

---

### Protocolul UDP
- Fara conexiune
- Simplu
- Rapid
- Overhead minim

---

### UDP: unitatea de transfer
- Datagrama
- Mesaje independente

---

### Header-ul UDP
- Source port
- Destination port
- Length
- Checksum

[FIG] c8-assets/fig-udp-header.png

---

### Checksum UDP
- Valideaza integritatea datelor
- Optional in IPv4
- Obligatoriu in IPv6

---

### Protocoale bazate pe UDP
- DNS
- DHCP
- TFTP
- SNMP

---

### TCP vs UDP (comparatie)
- TCP: fiabil, ordonat, stream
- UDP: rapid, neordonat, mesaje
- Alegerea depinde de aplicatie

---

### UDP vs TCP sub pierderi (context)
- In retele reale pot aparea pierderi de pachete
- UDP nu ofera mecanisme de corectie
- TCP retransmite automat segmentele pierdute
- Diferenta este vizibila la nivel aplicatie

---

### Scenariu: UDP vs TCP cu pierderi in Mininet
- Folosim Mininet pentru a simula o retea cu pierderi
- Introducem loss artificial pe link-uri
- Comparam comportamentul aplicatiilor UDP si TCP

Topologie:
- h1 --- s1 --- h2
- loss configurabil pe link-uri

---

### Ce urmarim in scenariu
- UDP:
  - nu toate mesajele ajung la destinatie
  - aplicatia observa lipsuri
- TCP:
  - aplicatia primeste stream complet
  - retransmisiile sunt transparente

---

### De ce Mininet
- Este deja folosit in cursurile anterioare
- Permite control fin al conditiilor de retea
- Evitam introducerea unui tool nou
- Simulam pierderi fara a modifica aplicatiile

---

### Rulare scenariu UDP vs TCP (Mininet)
- Se porneste un receiver pe h2
- Se trimit mesaje de pe h1
- Se repeta testul pentru UDP si TCP
- Se observa diferenta in output

[SCENARIO] c8-assets/scenario-udp-vs-tcp-loss-mininet/

---

### De ce este nevoie de TLS
- TCP si UDP transmit date in clar
- Atacatorul poate intercepta traficul

---

### TLS si DTLS
- TLS: peste TCP
- DTLS: peste UDP
- Ofera criptare si integritate

---

### TLS in stack-ul TCP/IP
- Ruleaza intre transport si aplicatie

[FIG] c8-assets/fig-tls-stack.png

---

### TLS – concepte de baza
- Schimb securizat de chei
- Criptare simetrica pentru date

---

### Protocoale TLS
- Handshake
- Cipher negotiation
- Alerts
- Data

---

### TLS 1.3 (idea)
- Handshake simplificat
- Latența redusa
- Securitate imbunatatita

[FIG] c8-assets/fig-tls-13.png

---

### Diffie-Hellman (idea)
- Schimb de chei pe canal nesigur
- Baza criptografiei moderne

[FIG] c8-assets/fig-diffie-hellman.png

---

### QUIC
- Protocol modern de nivel transport
- Ruleaza peste UDP
- Integreaza securitatea

---

### De ce QUIC?
- Reduce latența
- Evita limitarile TCP clasice
- Baza HTTP/3

---

### Stabilirea unei conexiuni QUIC
- 0-RTT sau 1-RTT
- Securitate integrata

[FIG] c8-assets/fig-quic-handshake.png

---

### Recapitulare
- Nivelul transport conecteaza rețeaua cu aplicatia
- TCP: fiabil, complex
- UDP: rapid, simplu
- TLS securizeaza transportul
- QUIC reprezinta evolutia moderna
