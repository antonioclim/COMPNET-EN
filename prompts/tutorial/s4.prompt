let's continue to the next tutorial: "Seminar 4 - Programare pe socket-uri: implementarea de protocoale text şi binare custom peste TCP şi UDP.
"

we're going to talk about implementing text and binary protocols. again i have some preexisting code to help you. something to take into account is that the tutorials are 80 minute long.

i don't think the examples cover everything they should:
- serializing commands as text
- serializing commands as binary
- (maybe) using protobuf
- protocol representation (simple and via a simplified representation of state machines)

I have examples for all of these, but we need to fit into the time requirement. Consider the examples a guideline more than anything. This is a bit too much to cover in the alloted time. Feel free to make alternate recommendations.

Code:

Binary proto server:
import socket
import threading
import collections
import pickle
import io

HOST = "127.0.0.1"  # Standard loopback interface address (localhost)
PORT = 3333  # Port to listen on (non-privileged ports are > 1023)

is_running = True
BUFFER_SIZE = 8

class Response:
  def __init__(self, payload):
    self.payload = payload

class Request:
  def __init__(self, command, key, resource = None):
    self.command = command
    self.key = key
    self.resource = resource

class State:
  def __init__(self):
    self.resources = {}
    self.lock = threading.Lock()
  def add(self, key, resource):
    self.lock.acquire()
    self.resources[key] = resource
    self.lock.release()
  def remove(self, key):
    self.lock.acquire()
    self.resources.pop(key, None)
    self.lock.release()
  def get(self, key):
    if key in self.resources:
      return self.resources[key]
    else:
      return None

state = State()

def process_command(data):
  payload = data[1:]
  stream = io.BytesIO(payload)  
  request = pickle.load(stream)
  payload = 'command not recognized, doing nothing'
  if request.command == 'add':
    state.add(request.key, request.resource)
    payload = f'{request.key} added'
  elif request.command == 'remove':
    state.remove(request.key)
    payload = f'{request.key} removed'
  elif request.command == 'get':
    payload = state.get(request.key)
    if not payload:
      payload = 'key was not found'
  stream = io.BytesIO()
  pickle.dump(Response(payload), stream)
  serialized_payload = stream.getvalue()
  payload_length = len(serialized_payload) + 1
  return payload_length.to_bytes(1, byteorder='big') + serialized_payload

def handle_client(client):
  with client:
    while True:
      if client == None:
        break
      is_new_command = True
      data = client.recv(BUFFER_SIZE)
      if not data:
        break
      binary_data = data
      full_data = binary_data
      message_length = binary_data[0]
      remaining = message_length - BUFFER_SIZE
      while remaining > 0:
        data = client.recv(BUFFER_SIZE)
        binary_data = data
        full_data = full_data + binary_data
        remaining = remaining - len(binary_data)
      response = process_command(full_data)
      client.send(response)

def accept(server):
  while is_running:
    client, addr = server.accept()
    print(f"{addr} has connected")
    client_thread = threading.Thread(target=handle_client, args=(client,))
    client_thread.start()

def main():
  try:
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.bind((HOST, PORT))
    server.listen()
    accept_thread = threading.Thread(target=accept, args=(server,))
    accept_thread.start()
    accept_thread.join()
  except BaseException as err:
    print(err)
  finally:
    if server:
      server.close()

if __name__ == '__main__':
  main()

Binary proto client:
import socket
import pickle
import io

HOST = "127.0.0.1"  # The server's hostname or IP address
PORT = 3333  # The port used by the server
BUFFER_SIZE = 8

class Response:
  def __init__(self, payload):
    self.payload = payload

class Request:
  def __init__(self, command, key, resource = None):
    self.command = command
    self.key = key
    self.resource = resource

def get_command(command):
    c = command.strip()
    items = c.split(' ')
    request = Request(items[0], items[1], ' '.join(items[2:]))
    stream = io.BytesIO()
    pickle.dump(request, stream)
    serialized_payload = stream.getvalue()
    payload_length = len(serialized_payload) + 1
    return payload_length.to_bytes(1, byteorder='big') + serialized_payload

with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.connect((HOST, PORT))
    command = ''
    while command.strip() != 'exit':
        command = input('connected>')
        s.send(get_command(command))
        data = s.recv(BUFFER_SIZE)
        if not data:
            break
        full_data = data
        message_length = data[0]
        remaining = message_length - len(data)
        while remaining > 0:
            data = s.recv(BUFFER_SIZE)
            full_data = full_data + data
            remaining = remaining - len(data)
        stream = io.BytesIO(full_data[1:])  
        response = pickle.load(stream)
        print(response.payload)


Text proto server:
import socket
import threading
import collections

HOST = "127.0.0.1"  # Standard loopback interface address (localhost)
PORT = 3333  # Port to listen on (non-privileged ports are > 1023)

is_running = True
BUFFER_SIZE = 8

class State:
  def __init__(self):
    self.resources = {}
    self.lock = threading.Lock()
  def add(self, key, resource):
    self.lock.acquire()
    self.resources[key] = resource
    self.lock.release()
  def remove(self, key):
    self.lock.acquire()
    self.resources.pop(key, None)
    self.lock.release()
  def get(self, key):
    if key in self.resources:
      return self.resources[key]
    else:
      return None

state = State()

def process_command(data):
  items = data.split(' ')
  command, key = items[1:3]
  resource = ''
  if len(items) > 3:
    resource = ' '.join(items[3:])
  payload = 'command not recognized, doing nothing'
  if command == 'add':
    state.add(key, resource)
    payload = f'{key} added'
  elif command == 'remove':
    state.remove(key)
    payload = f'{key} removed'
  elif command == 'get':
    payload = state.get(key)
    if not payload:
      payload = 'key was not found'
  payload_length = len(payload)
  message_length = len(str(payload_length)) + 1 + payload_length
  return f'{message_length} {payload}'

def handle_client(client):
  with client:
    while True:
      if client == None:
        break
      is_new_command = True
      data = client.recv(BUFFER_SIZE)
      if not data:
        break
      string_data = data.decode('utf-8')
      full_data = string_data
      message_length = int(string_data.split(' ')[0])
      remaining = message_length - len(string_data)
      while remaining > 0:
        data = client.recv(BUFFER_SIZE)
        string_data = data.decode('utf-8')
        full_data = full_data + string_data
        remaining = remaining - len(string_data)
      response = process_command(full_data)
      client.sendall(response.encode('utf-8'))

def accept(server):
  while is_running:
    client, addr = server.accept()
    print(f"{addr} has connected")
    client_thread = threading.Thread(target=handle_client, args=(client,))
    client_thread.start()

def main():
  try:
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.bind((HOST, PORT))
    server.listen()
    accept_thread = threading.Thread(target=accept, args=(server,))
    accept_thread.start()
    accept_thread.join()
  except BaseException as err:
    print(err)
  finally:
    if server:
      server.close()

if __name__ == '__main__':
  main()


Text proto client:
import socket

HOST = "127.0.0.1"  # The server's hostname or IP address
PORT = 3333  # The port used by the server
BUFFER_SIZE = 8

def get_command(command):
    c = command.strip()
    content_length = len(c)
    total_length = content_length + len(str(content_length)) + 1
    return (str(total_length) + ' ' + c).encode('utf-8')

with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.connect((HOST, PORT))
    command = ''
    while command.strip() != 'exit':
        command = input('connected>')
        s.sendall(get_command(command))
        data = s.recv(BUFFER_SIZE)
        if not data:
            break
        string_data = data.decode('utf-8')
        full_data = string_data
        message_length = int(string_data.split(' ')[0])
        remaining = message_length - len(string_data)
        while remaining > 0:
            data = s.recv(BUFFER_SIZE)
            string_data = data.decode('utf-8')
            full_data = full_data + string_data
            remaining = remaining - len(string_data)
        print(' '.join(full_data.split(' ')[1:]))

Udp transfer units server and client:
import socket
import sys

from transfer_units import RequestMessage, RequestMessageType, ResponseMessage, ResponseMessageType
from state import State
from serialization import serialize, deserialize

state = State()

def main():
  if len(sys.argv) < 2:
    print('not enough args')
  else:
    PORT = sys.argv[1]
    PORT = int(PORT)
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as server_socket:
      server_socket.bind(('', PORT))
      while True:
        message, address = server_socket.recvfrom(1024)
        request = deserialize(message)
        if request.message_type == RequestMessageType.CONNECT:
          state.add_connection(address)
          server_socket.sendto(serialize(ResponseMessage(ResponseMessageType.OK)), address)
        if request.message_type == RequestMessageType.SEND:
          if address in state.connections:
            state.add_note(address, request.payload)
            server_socket.sendto(serialize(ResponseMessage(ResponseMessageType.OK)), address)
          else:
            server_socket.sendto(serialize(ResponseMessage(ResponseMessageType.ERR_CONNECTED)), address)
        if request.message_type == RequestMessageType.LIST:
          if address in state.connections:
            server_socket.sendto(serialize(ResponseMessage(ResponseMessageType.OK, state.get_notes(address))), address)
          else:
            server_socket.sendto(serialize(ResponseMessage(ResponseMessageType.ERR_CONNECTED)), address)
        if request.message_type == RequestMessageType.DISCONNECT:
          state.remove_connection(address)
          server_socket.sendto(serialize(ResponseMessage(ResponseMessageType.OK)), address)


if __name__ == '__main__':
  main()

import socket
import sys

from transfer_units import RequestMessage, RequestMessageType, ResponseMessage, ResponseMessageType
from serialization import serialize, deserialize

def main():
  if len(sys.argv) < 3:
    print('not enough args')
  else:
    (HOST, PORT) = sys.argv[1:3]
    PORT = int(PORT)
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as client_socket:
      while True:
        data = input("storage>")
        items = data.strip().split(' ', 1)
        command = items[0]
        if command == 'connect':
          client_socket.sendto(serialize(RequestMessage(RequestMessageType.CONNECT)), (HOST, PORT))
        elif command == 'list':
          client_socket.sendto(serialize(RequestMessage(RequestMessageType.LIST)), (HOST, PORT))
        elif command == 'send':
          client_socket.sendto(serialize(RequestMessage(RequestMessageType.SEND, items[1])), (HOST, PORT))
        elif command == 'disconnect':
          client_socket.sendto(serialize(RequestMessage(RequestMessageType.DISCONNECT)), (HOST, PORT))
        else:
          print('unknown command')
          continue
        message, _ = client_socket.recvfrom(1024)
        deserialized_response = deserialize(message)
        print(deserialized_response)



if __name__ == '__main__':
  main()

import pickle
import io

def serialize(message):
  stream = io.BytesIO()
  pickle.dump(message, stream)
  serialized_message = stream.getvalue()
  return serialized_message

def deserialize(message):
  stream = io.BytesIO(message)
  deserialized_message = pickle.load(stream)
  return deserialized_message

from enum import Enum

class RequestMessageType(Enum):
  CONNECT = 1
  SEND = 2
  LIST = 3
  DISCONNECT = 4

class ResponseMessageType(Enum):
  OK = 1
  ERR_CONNECTED = 2

class RequestMessage():
  def __init__(self, message_type, payload = ''):
    self.message_type = message_type
    self.payload = payload
  def __str__(self):
    return f'''
--------------RESPONSE-------------
TYPE: {self.message_type}
{self.payload}
-----------------------------------
    '''

class ResponseMessage():
  def __init__(self, message_type, payload = ''):
    self.message_type = message_type
    self.payload = payload
  def __str__(self):
    return f'''
-------------RESPONSE-------------
TYPE: {self.message_type}
{self.payload}
----------------------------------
    '''

class State:
  def __init__(self):
    self.connections = {}
  def add_connection(self, address):
    self.connections.setdefault(address, [])
  def add_note(self, address, note):
    self.connections[address].append(note)
  def get_notes(self, address):
    return '\n'.join(self.connections[address])
  def remove_connection(self, address):
    del self.connections[address]