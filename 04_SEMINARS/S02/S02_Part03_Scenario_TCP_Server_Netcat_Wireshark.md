### Scenario: TCP server and client in Python, testing with netcat and analysing in Wireshark

#### 1. Objective

In this stage you will:

- run a TCP server in Python (example implementation);
- test the server with netcat;
- run a Python TCP client (example + template);
- capture and analyse TCP traffic in Wireshark: handshake, payload and teardown;
- understand why TCP behaves as a stream and why this affects framing.

---

### 2. Running the example TCP server

Start the reference TCP server:

```bash
python3 S02_Part01_Example_TCP_Server.py
```

It listens on `127.0.0.1:12345` and prints a message when it starts.

Leave the server running.

---

### 3. Testing the TCP server with netcat

In another terminal, connect with netcat:

```bash
nc 127.0.0.1 12345
```

Type a few messages (press Enter after each line). Observe:

- server terminal: it logs the received message and the client address;
- netcat terminal: it receives the response (uppercase echo).

---

### 4. Testing the server with the example Python client

Run the simple client:

```bash
python3 S02_Part04_Example_TCP_Client.py
```

By default it connects to `127.0.0.1:12345`, sends one message and prints the reply.

---

### 5. Capturing TCP traffic in Wireshark

1. Open **Wireshark** and select the relevant interface (`lo`, `eth0`, `wlan0`, etc.).

2. Configure a **capture filter** for the TCP port used:

```text
tcp port 12345
```

3. Start capture.

4. While capture is running:

- connect with netcat and send 2–3 messages;
- run the example Python client once.

5. Stop capture and apply a **display filter**:

```text
tcp.port == 12345
```

Observe:

- the TCP handshake (SYN, SYN-ACK, ACK),
- packets that contain payload,
- connection termination (FIN/ACK or RST),
- `tcp.stream` as the concept that groups a conversation.

---

### 6. Student task – completing the TCP server (template)

1. Open `S02_Part02_Template_TCP_Server.py`.

2. Implement the logic described in the `TODO` block:

- decode the message,
- detailed log with IP, port, text and number of bytes,
- implement the protocol:

  - `ping` → `PONG`
  - `upper:...` → the part after `upper:` in uppercase
  - anything else → `UNKNOWN COMMAND`

3. Run the template server:

```bash
python3 S02_Part02_Template_TCP_Server.py
```

4. Test it:

- with netcat:

  ```bash
  nc 127.0.0.1 12345
  ping
  upper:hello world
  abc
  ```

- with the example client (if you adjust it to send your custom messages).

Observe responses and logs.

---

### 7. Student task – completing the interactive TCP client (template)

1. Open `S02_Part05_Template_TCP_Client.py`.

2. Complete the `TODO` section according to the requirements:

- interactive loop until `exit`,
- send a message to the server,
- receive and print the response,
- optional timeout on receive,
- final statistics (sent/received/timeouts).

3. Run the client:

```bash
python3 S02_Part05_Template_TCP_Client.py
```

Send at least 5 messages:

- two `ping`,
- two `upper:...`,
- one random text (e.g., `abc`).

---

### 8. Wireshark capture for Python–Python communication

1. Start a new capture with the same capture filter:

```text
tcp port 12345
```

2. While capture is running:

- start the template server,
- run the template client and send the 5 test messages.

3. Stop capture and apply:

```text
tcp.port == 12345
```

4. For at least two messages:

- identify the request segment (client → server),
- identify the response segment (server → client),
- compare Wireshark timing with what you observe in the client logs.

---

### 9. Work evidence (what you will upload)

1. `tcp_server_activity_output.txt`:

- the commands used to run the example and template server,
- at least 5 server log lines (for different commands: `ping`, `upper:...` and others),
- a short comment (3–5 sentences) about the behaviour of the protocol.

2. `tcp_client_activity_output.txt`:

- the interactive client logs (sent messages and received replies),
- final statistics.

3. `tcp_traffic_capture.pcapng`:

- Wireshark capture that includes the traffic generated by your tests.

These files will demonstrate that you understand:

- how TCP works at code level,
- how TCP traffic looks in Wireshark (handshake, payload and teardown),
- how TCP differs from UDP (next stage).
