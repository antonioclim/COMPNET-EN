### Scenario: multi-client TCP server with threads (mini "chat") + testing with netcat / Python client + Wireshark

#### 1. Objective

In this stage you will:

- understand how a multi-client TCP server with threads operates;
- run the example server and test it with several simultaneous clients (netcat or the client from the previous tutorial);
- modify a template to implement a mini "chat" (messages from one client are forwarded to the others);
- analyse the traffic generated by multiple simultaneous clients in Wireshark.

---

### 2. Running the example server

1. Start the example server:

```bash
python3 index_tcp-multiclient-server_example.py
````

You should see:

```text
[START] TCP multi-client server on 127.0.0.1:3333
[INFO] Server ready, listening on 127.0.0.1:3333
```

Leave the server running.

---

### 3. Connecting multiple clients (netcat or Python client)

Open **at least 2–3 additional terminals**.

#### Option A – netcat

In each terminal:

```bash
nc 127.0.0.1 3333
```

Type messages and press Enter. In the server terminal you should observe:

* `[CONNECT] New client ...` appearing for each client;
* `[RECV]` and `[SEND]` appearing for each message.

#### Option B – Python client from the previous tutorial

Use the TCP client with the port adjusted to 3333 (if necessary, change `PORT = 3333`):

```bash
python3 index_tcp-client_template.py
```

Send messages from 2 client instances.

---

### 4. Capturing multi-client traffic in Wireshark

1. Open **Wireshark** and select the relevant interface (`lo`, `Loopback`, `eth0`, `wlan0`, etc.).

2. Set a **capture filter**:

```text
tcp port 3333
```

3. Start the capture.

4. While the capture is running:

   * connect 2–3 clients;
   * send 2–3 messages from each client.

5. Stop the capture and apply a **display filter**:

```text
tcp.port == 3333
```

Observe:

* multiple TCP streams in parallel (e.g. `tcp.stream eq 0`, `tcp.stream eq 1`, etc.);
* the fact that each client has its own stream with the server;
* the time difference between client messages.

---

### 5. Student task – implementing the mini "chat"

1. Open the file `index_tcp-multiclient-server_template.py`.

2. Complete the marked section:

```python
# >>> STUDENT CODE STARTS HERE
...
# <<< STUDENT CODE ENDS HERE
```

Following the requirements in the comments:

* clear log for each received message;
* construct a message of the form `[ip:port] text...`;
* send the message to all other clients in the `clients` list.

3. Run the template server:

```bash
python3 index_tcp-multiclient-server_template.py
```

4. Open at least **3 clients**:

* either with `nc 127.0.0.1 3333`,
* or with the Python client (modified to use port 3333).

5. Send messages from one client and verify that:

* they arrive in the **other** clients;
* the server logs show to which clients the message was forwarded (`[FWD] ...`).

---

### 6. Wireshark capture for the mini "chat"

1. Start **a new capture** with the same **capture filter**:

```text
tcp port 3333
```

2. While the capture is running:

* run the template server;
* connect 3 clients;
* send several "cross" messages (client 1 to client 2, client 2 to client 3, etc.).

3. Stop the capture and apply the display filter:

```text
tcp.port == 3333
```

4. Analyse:

* the packets sent from a client to the server (request);
* the packets from the server to the other clients (forward/broadcast);
* how the streams of different clients (`tcp.stream eq N`) appear in Wireshark.

---

### 7. Proof of work (what to submit)

1. `tcp_multiclient_server_output.txt`:

   * the command used to start the server;
   * server logs for at least 5 messages (from different clients);
   * 5–7 sentences in which you explain:

     * how the logs confirm that multiple clients are connected;
     * how the logs relate to the packets in Wireshark.

2. `tcp_multiclient_chat_capture.pcapng`:

   * the Wireshark capture containing the traffic generated by the mini "chat".

